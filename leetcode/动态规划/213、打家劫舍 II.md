## 打家劫舍II

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。  

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。  

示例 1:  
输入: [2,3,2]  
输出: 3  
解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。  

示例 2:  
输入: [1,2,3,1]  
输出: 4  
解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。  
     偷窃到的最高金额 = 1 + 3 = 4 。  


### 动态规划
1、环状排列意味着第一个房子和最后一个房子中只能选择一个偷窃，有两个选择：
* 在不偷窃第一个房子的情况下(nums[1:])，最大金额为p1；  
* 在不偷窃最后一个房子的情况下（nums[:n-1])，最大金额为p2.  
综合偷窃最大金额：max(p1, p2)  

2、状态定义：dp[i]为前i个房子在满足条件下能偷窃到的最大金额  

3、转移方程：前n间能偷窃的房子最大金额为dp[n], 前n-1间能偷窃到的最高金额是dp[n-1],此时向后加一间房为num。  
* 由于不能偷窃相邻的房子，意味着抢第n+1间就不能抢第n间：那么就有两个较大值：  
* 不偷窃第n+1个房间，因此等于前n个房子的最大金额，即dp[n+1] = dp[n];  
* 偷窃第n+1个房间，此时不能偷窃第n个房间，因此等于前n——1个房子的最大金额加上当前房间价值，即dp[n+1] = dp[n-1] + num;  
* 最终的转移方程： dp[n+1] = max(dp[n], dp[n-1] + num)  

4、初始状态，前0间房子能偷窃的最大金额为0  

5、发现dp[n]只与dp[n-1]和dp[n-2]有关系，因此可以用cur和pre代替，降低空间复杂度为O(1)

```
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
    const len = nums.length;
    if (len === 0) return 0;
    if (len === 1) return nums[0];
    return Math.max(myRob(nums, 0, len - 1), myRob(nums, 1, len));

    function myRob (nums, start, end) {
        let pre = 0, cur = 0, tmp;
        for (let i = start; i < end; i++) {
            tmp = cur;
            cur = Math.max(pre + nums[i], cur);
            pre = tmp;
        }
        return cur
    }
};
```
