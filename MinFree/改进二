改进一是以空间上的消耗为代价做了速度上的改进。由于维护一个长度为n+1的标志数组，当n很大时，空间上的性能就成了新的瓶颈。
分而治之的典型策略是将问题分解为若干规模较小的子问题，然后逐步解决它们以得到最终结果。

分而治之：
将所有满足xi <= [n/2]的整数放入一个子序列A'，并将剩余的整数放入另一个序列A".如果序列A'的长度正好是[n/2]，这说明前一半的整数已经满了，最小的可用整数一定可以在A"中递归找到。否则，最小的可用整数可以在A'中找到。通过这一划分，问题的规模就减少了。
需要注意的是，当在子序列A"中递归查找时，边界情况发生了一些变化：不再是从0开始寻找最小可用整数，查找的下届变成了[n/2]+1。因此，算法应定义为minfree[A,l,n],其中l是下界，n是上界
递归结束的边界条件是待查找的序列为空

根据思路，分而治之的解法可以形式化为一个函数
minfree(A) = search(A, 0, n-1)

search(A, l ,u) = {
  l: A = ∅,
  search(A", m +1, u): |A'| = m - l +1,
  search(A', 0, m): 其他
}
其中：
m = (l+u)/2
A' = {∀x ∈ A ∩ x <= m}
A" = {∀x ∈ A ∩ x > m}

这个方法并不需要额外的空间。每次调用我们都需要进行O(|A|)次比较，来划分出子序列A'和A"，之后规模就减半。
第一次需要O(n)次比较来划分子序列A'和A"，第二次仅需要O(n/2)次，第三次需要比较O(n/4)次。。。总时间为O(n+n/2+n/4...) = O(2n) = O(n)

使用haskell将划分一个序列作为库函数提供
import Data.List
minFree xs = bsearch xs - (length xs - 1)
bsearch xs 1 u | xs == [] = 1
               | length as == m - 1 + 1 = bsearch bs (m+1) u
               | otherwise = bsearch as 1 m
  where
    m = (1 + u) `div` 2
    (as, bs) = partition (<=m) xs
